import sys
import io
import json
import os
import random
import urllib.parse
import logging
from datetime import datetime, timedelta
from functools import wraps
import os
from flask import Flask, request, jsonify, render_template, send_from_directory, url_for, session, make_response
from flask_cors import CORS
import os
import cv2
import numpy as np
import logging
import json
from datetime import datetime
import traceback
import base64
import shutil
from twilio.rest import Client
from dotenv import load_dotenv
import urllib.parse
from werkzeug.utils import secure_filename
from logging.handlers import RotatingFileHandler
import sys
from logging import StreamHandler
from jinja2.exceptions import TemplateError

# Cargar variables de entorno
load_dotenv()

# Configuraci√≥n de WhatsApp
TWILIO_ACCOUNT_SID = os.getenv('TWILIO_ACCOUNT_SID')
TWILIO_AUTH_TOKEN = os.getenv('TWILIO_AUTH_TOKEN')
WHATSAPP_NUMBER = 'whatsapp:+14155238886'  # N√∫mero de Twilio
DESTINATION_NUMBER = 'whatsapp:+527292553437'  # N√∫mero de destino

# Forzar la codificaci√≥n UTF-8
if sys.stdout.encoding != 'utf-8':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
if sys.stderr.encoding != 'utf-8':
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# Configuraci√≥n de logging
class UnicodeStreamHandler(logging.StreamHandler):
    def emit(self, record):
        try:
            msg = self.format(record)
            stream = self.stream
            stream.write(msg + self.terminator)
            self.flush()
        except UnicodeEncodeError:
            # Si hay un error de codificaci√≥n, intentamos con reemplazos seguros
            msg = record.msg.encode('ascii', 'replace').decode('ascii')
            record.msg = msg
            msg = self.format(record)
            stream = self.stream
            stream.write(msg + self.terminator)
            self.flush()
        except Exception:
            self.handleError(record)

# Configurar el logger root
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        UnicodeStreamHandler(),
        logging.FileHandler('chatbot.log', encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

# Inicializar la aplicaci√≥n Flask
app = Flask(__name__, template_folder='templates')
app.secret_key = 'tu_clave_secreta_aqui'  # Necesario para usar sesiones

# Configuraci√≥n de la carpeta de plantillas
app.config['TEMPLATES_AUTO_RELOAD'] = True

# Configuraci√≥n para subida de archivos
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max-limit
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=1)

# Configuraci√≥n de reconocimiento facial
FACE_CASCADE = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
SIMILARITY_THRESHOLD = 0.6  # Umbral de similitud para la comparaci√≥n de rostros

# Configuraci√≥n de l√≠mite de tasa
RATE_LIMIT = 10  # M√°ximo de solicitudes por minuto
rate_limits = {}

# Cargar intenciones
def cargar_intenciones():   
    """Carga las intenciones desde los archivos JSON"""
    intents = []
    archivos = ['intents.json']  # Solo cargamos intents.json por ahora
    
    for archivo in archivos:
        try:
            logger.info(f"Cargando archivo: {archivo}")
            with open(archivo, 'r', encoding='utf-8') as f:
                content = f.read()
                try:
                    data = json.loads(content)
                except json.JSONDecodeError as e:
                    logger.error(f"Error de sintaxis JSON en {archivo}: {e}")
                    # Intentar limpiar el contenido
                    content = content.encode('utf-8', 'ignore').decode('utf-8')
                    data = json.loads(content)
                
                if 'intents' in data:
                    intents.extend(data['intents'])
                else:
                    intents.append(data)
            logger.info(f"Archivo cargado: {archivo} - {len(intents)} intenciones encontradas")
        except Exception as e:
            logger.error(f"Error al cargar {archivo}", exc_info=True)
            continue
    
    # Crear un diccionario de etiquetas a respuestas para b√∫squeda m√°s r√°pida
    intents_dict = {}
    for intent in intents:
        if 'tag' in intent:
            intents_dict[intent['tag']] = intent
    
    logger.info(f"Total de etiquetas cargadas: {len(intents_dict)}")
    return intents, intents_dict

# Cargar intenciones al inicio
intents, intents_dict = cargar_intenciones()

def rate_limit(f):
    """Decorador para limitar la tasa de solicitudes"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        ip = request.remote_addr
        now = datetime.now()
        
        if ip not in rate_limits:
            rate_limits[ip] = {'count': 0, 'reset_time': now + timedelta(minutes=1)}
        
        if now > rate_limits[ip]['reset_time']:
            rate_limits[ip] = {'count': 0, 'reset_time': now + timedelta(minutes=1)}
        
        if rate_limits[ip]['count'] >= RATE_LIMIT:
            return jsonify({
                'response': 'Has excedido el l√≠mite de solicitudes. Por favor, espera un momento.',
                'status': 'rate_limited'
            }), 429
        
        rate_limits[ip]['count'] += 1
        return f(*args, **kwargs)
    return decorated_function

def obtener_respuesta(mensaje):
    """Obtiene la mejor respuesta para el mensaje del usuario"""
    mensaje = mensaje.lower()
    
    # Buscar en las intenciones cargadas
    for intent in intents:
        for pattern in intent.get('patterns', []):
            if mensaje in pattern.lower():
                return random.choice(intent.get('responses', []))
    
    # Si no se encuentra una coincidencia exacta, devolver una respuesta por defecto
    respuestas_por_defecto = [
        "No estoy seguro de entenderte. ¬øPodr√≠as reformular tu pregunta?",
        "No tengo una respuesta para eso en este momento. ¬øHay algo m√°s en lo que pueda ayudarte?",
        "Voy a derivar tu consulta a un agente. Mientras tanto, ¬øhay algo m√°s en lo que pueda ayudarte?"
    ]
    
    return random.choice(respuestas_por_defecto)

# Rutas
@app.route('/')
def home():
    """Ruta principal que muestra la interfaz del chat"""
    return render_template('index.html')

@app.route('/chat', methods=['POST'])
@rate_limit
def chat():
    """Endpoint para manejar los mensajes del chat"""
    try:
        data = request.get_json()
        message = data.get('message', '').strip()
        plan_seleccionado = data.get('planSeleccionado')
        datos_contratacion = data.get('datosContratacion')
        
        if not message:
            return jsonify({'response': 'Por favor, escribe un mensaje v√°lido.'})
        
        respuesta = None
        
        # Si es un mensaje de confirmaci√≥n de contrataci√≥n
        if datos_contratacion:
            try:
                # Aqu√≠ podr√≠as guardar los datos en una base de datos
                logger.info(f"Datos de contrataci√≥n recibidos: {datos_contratacion}")
                
                # Crear un resumen de la contrataci√≥n
                plan = datos_contratacion['plan']
                resumen = (
                    f"‚úÖ *Solicitud de contrataci√≥n recibida*\n\n"
                    f"üìã *Plan seleccionado:* {plan['nombre']}\n"
                    f"üí≤ *Precio:* ${plan['precio']}\n"
                    f"üë§ *Cliente:* {datos_contratacion['nombreCompleto']}\n"
                    f"üìû *Tel√©fono:* {datos_contratacion['telefono']}\n"
                    f"üìß *Email:* {datos_contratacion['email']}\n"
                    f"üè† *Direcci√≥n:* {datos_contratacion['direccion']}\n"
                    f"üìÖ *Fecha y hora preferidas:* {datos_contratacion['fechaHora']}\n\n"
                    f"Un asesor se pondr√° en contacto contigo en breve para confirmar los detalles de tu instalaci√≥n.\n"
                    f"¬°Graza por elegirnos! üòä"
                )
                
                return jsonify({
                    'response': resumen,
                    'status': 'success',
                    'limpiarPlan': True
                })
                
            except Exception as e:
                logger.error(f"Error al procesar datos de contrataci√≥n: {e}")
                return jsonify({
                    'response': 'Hubo un error al procesar tu solicitud. Por favor, int√©ntalo de nuevo m√°s tarde.',
                    'status': 'error'
                })
        
        # Si hay un plan seleccionado pero a√∫n no se ha completado el formulario
        if plan_seleccionado and not datos_contratacion:
            # Verificar si el mensaje parece ser una respuesta al formulario
            lineas = message.split('\n')
            if len(lineas) >= 5:
                # El usuario est√° respondiendo al formulario, ya se maneja en el frontend
                pass
            else:
                # Recordar el plan seleccionado
                logger.info(f"Plan seleccionado: {plan_seleccionado}")
                respuesta = obtener_respuesta('recordar_plan')
                respuesta = respuesta.replace('{plan}', plan_seleccionado['nombre'])
                respuesta = respuesta.replace('{precio}', str(plan_seleccionado['precio']))
                return jsonify({
                    'response': respuesta,
                    'status': 'success'
                })
        
        # Obtener respuesta normal del chatbot
        if not respuesta:
            respuesta = obtener_respuesta(message)
        
        return jsonify({
            'response': respuesta,
            'status': 'success'
        })
        
    except Exception as e:
        logger.error(f"Error en el endpoint /chat: {e}", exc_info=True)
        return jsonify({
            'response': 'Lo siento, ha ocurrido un error al procesar tu mensaje.',
            'status': 'error'
        }), 500

# Ruta para obtener el horario de atenci√≥n
@app.route('/horarios-atencion')
def horarios_atencion():
    """Devuelve el HTML del horario de atenci√≥n desde el template modularizado"""
    return render_template('HorariosAtencion.html')

@app.route('/get_horario')
def get_horario():
    """Devuelve el HTML del horario de atenci√≥n"""
    horario_html = """
    <div class='response-card'>
      <div class='card-header'>
        <span class='card-icon'>‚è∞</span>
        <span class='card-title'>Horarios de Atenci√≥n</span>
      </div>
      <div class='schedule-list'>
        <div class='schedule-item'><span class='day'>Lunes a Viernes</span><span class='hours'>09:00 a.m. - 06:00 p.m.</span></div>
        <div class='schedule-item'><span class='day'>S√°bados</span><span class='hours'>09:00 a.m. - 03:00 p.m.</span></div>
        <div class='schedule-item'><span class='day'>Domingos</span><span class='hours closed'>Cerrado</span></div>
      </div>
      <div class='note'>* Pagos disponibles 24/7 por transferencia o dep√≥sito</div>
      <div class='emergency-contact'>
        <span class='emergency-icon'>üö®</span> Emergencias t√©cnicas: <b>55-9999-8888</b> (24/7 solo fallas graves)
      </div>
    </div>
    """
    return horario_html

# Ruta para obtener la informaci√≥n de sucursales (redirige a la nueva p√°gina de sucursales)
@app.route('/get_sucursales')
def get_sucursales():
    """Redirige a la nueva p√°gina de sucursales"""
    from flask import redirect, url_for
    return redirect(url_for('sucursales'))


# Ruta para la p√°gina de sucursales
@app.route('/sucursales')
def sucursales():
    return render_template('8.Sucursales.html')

@app.route('/api/sucursales')
def api_sucursales():
    sucursales = [
        {
            "nombre": "Santiago Tianguistenco",
            "direccion": [
                "ANDADOR CARLOS HANK GONZALEZ #304, SANTIAGO TIANGUISTENCO, ESTADO DE MEXICO",
                "JUNTO AL BANCO SANTANDER"
            ],
            "horario": ["L-V 9:00 AM - 6:00 PM", "S√°bados: 9:00 AM - 3:00 PM"],
            "mapa": "https://www.google.com/maps/place/M-net+Sistemas+Computadoras+e+Internet/@19.1816993,-99.4694112,764m/data=!3m2!1e3!4b1!4m6!3m5!1s0x85cdf3d2a5c1d91f:0x59b36638210c9c11!8m2!3d19.1816993!4d-99.4668363!16s%2Fg%2F11c6112plc?entry=ttu&g_ep=EgoyMDI1MDUyMS4wIKXMDSoJLDEwMjExNDU1SAFQAw%3D%3D",
            "whatsapp": "https://wa.me/525587654321",
            "imagen": "https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80"
        },
        {
            "nombre": "Santa M√≥nica",
            "direccion": [
                "GALEANA #27 CARR. MEXICO-CHALMA COL. EL PICACHO, OCUILAN DE ARTEAGA, ESTADO DE MEXICO",
                "JUNTO A FEDEX"
            ],
            "horario": ["L-V 9:00 AM - 6:00 PM", "S√°bados: 9:00 AM - 3:00 PM"],
            "mapa": "https://maps.app.goo.gl/bw4Q7EGeADY1Z6xd7",
            "whatsapp": "https://wa.me/525587654321",
            "imagen": "https://images.unsplash.com/photo-1520333789090-1afc82db536a?ixlib=rb-1.2.1&auto=format&fit=crop&w=1351&q=80"
        },
        {
            "nombre": "Cholula",
            "direccion": [
                "JOSE MA. MORELOS S/N, ESQUINA CON BENITO JUAREZ GARCIA COL. MORELOS, SAN PEDRO CHOLULA, ESTADO DE MEXICO",
                "DEBAJO DEL HOTEL CHOLULA"
            ],
            "horario": ["L-V 9:00 AM - 6:00 PM", "S√°bados: 9:00 AM - 3:00 PM"],
            "mapa": "https://maps.app.goo.gl/9A7pdCtpqeEQzSnf6",
            "whatsapp": "https://wa.me/525587654321",
            "imagen": "https://images.unsplash.com/photo-1517502884422-41eaead166d4?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80"
        }
    ]
    return jsonify(sucursales)


# Ruta para obtener los m√©todos de pago
@app.route('/get_metodos_pago')
def get_metodos_pago():
    """Devuelve el HTML de los m√©todos de pago"""
    return render_template('9.MetodosPago.html')


# Ruta para servir archivos est√°ticos
@app.route('/static/<path:path>')
def static_file(path):
    return send_from_directory('static', path)

# Ruta espec√≠fica para el archivo de cascada Haar
@app.route('/haarcascade_frontalface_default.xml')
def serve_haar():
    """Sirve el archivo de cascada Haar para la detecci√≥n facial."""
    try:
        # Asegurarse de que la ruta al archivo sea correcta
        haar_path = os.path.join(app.static_folder, 'haarcascade_frontalface_default.xml')
        if not os.path.exists(haar_path):
            app.logger.error(f'Archivo Haar Cascade no encontrado en: {haar_path}')
            return 'Archivo Haar Cascade no encontrado', 404
            
        app.logger.info(f'Sirviendo archivo Haar Cascade desde: {haar_path}')
        return send_file(haar_path, mimetype='application/xml')
    except Exception as e:
        app.logger.error(f'Error al servir el archivo Haar Cascade: {str(e)}')
        return f'Error al cargar el clasificador: {str(e)}', 500
    return send_from_directory('static', 'haarcascade_frontalface_default.xml')

# Ruta para servir archivos est√°ticos de la c√°mara
@app.route('/camera/static/<path:path>')
def serve_camera_static(path):
    return send_from_directory('static', path)

# Ruta para servir archivos CSS
@app.route('/css/<path:filename>')
def serve_css(filename):
    response = send_from_directory(os.path.join('static', 'css'), filename)
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

# Ruta para servir archivos JS
@app.route('/js/<path:filename>')
def serve_js(filename):
    response = send_from_directory(os.path.join('static', 'js'), filename)
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

# Ruta para servir el template de contrataci√≥n
@app.route('/contratar')
def contratar():
    return render_template('1.ContratarServicio.html')

# Ruta para servir el formulario de contrataci√≥n v√≠a AJAX
@app.route('/contratar-servicio')
def contratar_servicio():
    # Renderizar contenido del √°rea de chat con dise√±o estilo Apple
    from flask import Response
    html_content = """
    <div class="message-container">
        <div class="bot-message">
            <div class="welcome-message">
                <h2>Bienvenido</h2>
                <p>Estoy aqu√≠ para ayudarte a contratar el servicio de internet perfecto para ti.</p>
            </div>
            <div class="message-content">
                <p>Selecciona el tipo de servicio que mejor se adapte a tus necesidades:</p>
                <div class="service-options">
                    <button class="service-btn" data-service="residencial">
                        <span>Internet Residencial</span>
                    </button>
                    <button class="service-btn" data-service="empresarial">
                        <span>Internet Empresarial</span>
                    </button>
                    <button class="service-btn" data-service="telefonia">
                        <span>Telefon√≠a en la Nube</span>
                    </button>
                    <button class="service-btn" data-service="videovigilancia">
                        <span>Videovigilancia</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    """
    return Response(html_content, mimetype='text/html')

# Ruta para subir INE
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}

# Asegurarse de que la carpeta de subidas exista
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def enviar_whatsapp(mensaje, media_urls=None):
    """Guarda localmente el mensaje y las im√°genes en lugar de enviar por WhatsApp"""
    try:
        # Crear directorio para los mensajes si no existe
        mensajes_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'mensajes_whatsapp')
        os.makedirs(mensajes_dir, exist_ok=True)
        
        # Crear un archivo con la informaci√≥n del mensaje
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        mensaje_file = os.path.join(mensajes_dir, f'mensaje_{timestamp}.txt')
        
        with open(mensaje_file, 'w', encoding='utf-8') as f:
            f.write(f"Mensaje: {mensaje}\n\n")
            f.write(f"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            
            if media_urls:
                f.write("\nIm√°genes adjuntas:\n")
                for i, url in enumerate(media_urls, 1):
                    f.write(f"{i}. {url}\n")
        
        logger.info(f"Mensaje guardado en: {mensaje_file}")
        
        # Si hay URLs de medios, copiarlas al directorio de mensajes
        if media_urls:
            for i, url in enumerate(media_urls, 1):
                try:
                    # Extraer el nombre del archivo de la URL
                    filename = os.path.basename(url)
                    src_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                    dst_path = os.path.join(mensajes_dir, f'imagen_{i}_{filename}')
                    
                    # Copiar el archivo
                    import shutil
                    shutil.copy2(src_path, dst_path)
                    logger.info(f"Imagen guardada en: {dst_path}")
                except Exception as e:
                    logger.error(f"Error al copiar la imagen {url}: {str(e)}")
        
        return True
    except Exception as e:
        logger.error(f"Error al guardar el mensaje: {str(e)}")
        return False

@app.route('/upload-ine', methods=['POST'])
def upload_ine():
    if 'ine' not in request.files:
        return jsonify({'error': 'No se encontr√≥ el archivo', 'success': False}), 400
    
    file = request.files['ine']
    if file.filename == '':
        return jsonify({'error': 'No se seleccion√≥ ning√∫n archivo', 'success': False}), 400
    
    if file and allowed_file(file.filename):
        try:
            # Asegurarse de que el directorio de subidas existe
            os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
            cliente_id = request.form.get('cliente_id', 'desconocido')
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Guardar el archivo de INE
            ine_filename = f"{cliente_id}_ine_{timestamp}.jpg"
            ine_filepath = os.path.join(app.config['UPLOAD_FOLDER'], ine_filename)
            file.save(ine_filepath)
            
            # Crear URL accesible para la imagen
            ine_url = url_for('uploaded_file', filename=ine_filename, _external=True)
            
            # Verificar que el archivo es una imagen v√°lida
            try:
                img = cv2.imread(ine_filepath)
                if img is None:
                    raise ValueError('El archivo no es una imagen v√°lida')
                
                # Verificar si hay un rostro en la imagen
                gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                faces = FACE_CASCADE.detectMultiScale(gray, 1.1, 4)
                
                if len(faces) == 0:
                    # Eliminar el archivo si no hay rostros
                    if os.path.exists(ine_filepath):
                        os.remove(ine_filepath)
                    return jsonify({
                        'success': False,
                        'error': 'No se detect√≥ ning√∫n rostro en la imagen. Por favor, suba una foto donde sea visible su rostro.'
                    }), 400
                
                # Guardar la ruta del archivo en la sesi√≥n para usarla despu√©s
                session['ine_filepath'] = ine_filepath
                session['ine_url'] = ine_url
                session['ine_filename'] = ine_filename
                
                # Si todo est√° bien, devolver √©xito
                return jsonify({
                    'success': True,
                    'message': 'INE cargada correctamente',
                    'shouldStartFacialRecognition': True,
                    'clienteId': cliente_id,
                    'ine_url': ine_url
                })
                
            except Exception as e:
                logger.error(f'Error al procesar la imagen: {str(e)}')
                # Eliminar el archivo si hubo un error
                if os.path.exists(ine_filepath):
                    os.remove(ine_filepath)
                return jsonify({
                    'success': False,
                    'error': f'Error al procesar la imagen: {str(e)}'
                }), 400
                
        except Exception as e:
            logger.error(f'Error al guardar el archivo: {str(e)}')
            return jsonify({
                'success': False,
                'error': f'Error al guardar el archivo: {str(e)}'
            }), 500
    
    return jsonify({
        'success': False,
        'error': 'Tipo de archivo no permitido. Por favor, suba una imagen (JPG, PNG, JPEG, GIF).'
    }), 400

@app.route('/upload-selfie', methods=['POST'])
def upload_selfie():
    """Endpoint para subir la selfie y guardar ambas im√°genes localmente"""
    if 'selfie' not in request.files:
        return jsonify({'error': 'No se encontr√≥ la selfie', 'success': False}), 400
    
    file = request.files['selfie']
    if file.filename == '':
        return jsonify({'error': 'No se captur√≥ ninguna selfie', 'success': False}), 400
    
    try:
        # Asegurarse de que el directorio de subidas existe
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        
        # Obtener datos de la sesi√≥n
        ine_filepath = session.get('ine_filepath')
        ine_url = session.get('ine_url')
        cliente_id = request.form.get('cliente_id', 'desconocido')
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if not ine_filepath or not os.path.exists(ine_filepath):
            return jsonify({
                'success': False,
                'error': 'No se encontr√≥ el archivo de INE. Por favor, intente de nuevo.'
            }), 400
        
        # Guardar la selfie
        selfie_filename = f"{cliente_id}_selfie_{timestamp}.jpg"
        selfie_filepath = os.path.join(app.config['UPLOAD_FOLDER'], selfie_filename)
        file.save(selfie_filepath)
        
        # Crear URL accesible para la selfie
        selfie_url = url_for('uploaded_file', filename=selfie_filename, _external=True)
        
        # Crear mensaje con la informaci√≥n de las im√°genes
        mensaje = f"Nueva verificaci√≥n de identidad\nCliente: {cliente_id}\nFecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        # Guardar localmente el mensaje y copiar las im√°genes
        mensajes_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'mensajes_whatsapp')
        os.makedirs(mensajes_dir, exist_ok=True)
        
        # Crear un archivo con la informaci√≥n del mensaje
        mensaje_file = os.path.join(mensajes_dir, f'mensaje_{timestamp}.txt')
        with open(mensaje_file, 'w', encoding='utf-8') as f:
            f.write(f"Mensaje: {mensaje}\n\n")
            f.write(f"Cliente: {cliente_id}\n")
            f.write(f"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("\nArchivos guardados:\n")
            f.write(f"1. INE: {ine_url}\n")
            f.write(f"2. Selfie: {selfie_url}\n")
        
        # Copiar las im√°genes al directorio de mensajes
        try:
            import shutil
            # Copiar INE
            ine_filename = os.path.basename(ine_filepath)
            shutil.copy2(ine_filepath, os.path.join(mensajes_dir, f'ine_{ine_filename}'))
            # Copiar selfie
            shutil.copy2(selfie_filepath, os.path.join(mensajes_dir, f'selfie_{selfie_filename}'))
        except Exception as e:
            logger.error(f"Error al copiar archivos: {str(e)}")
        
        # Limpiar la sesi√≥n
        session.pop('ine_filepath', None)
        session.pop('ine_url', None)
        
        # Crear enlace de WhatsApp con las im√°genes
        mensaje_whatsapp = f"Verificaci√≥n de identidad completada para el cliente {cliente_id}"
        mensaje_whatsapp += f"\nINE: {ine_url}"
        mensaje_whatsapp += f"\nSelfie: {selfie_url}"
        
        # Codificar el mensaje para la URL
        mensaje_codificado = urllib.parse.quote(mensaje_whatsapp)
        
        # Crear URL de WhatsApp Web
        whatsapp_url = f"https://web.whatsapp.com/send?text={mensaje_codificado}"
        
        return jsonify({
            'success': True,
            'message': 'Verificaci√≥n completada exitosamente. Redirigiendo a WhatsApp...',
            'whatsapp_url': whatsapp_url,
            'ine_url': ine_url,
            'selfie_url': selfie_url,
            'local_path': os.path.abspath(mensajes_dir)
        })
        
    except Exception as e:
        logger.error(f'Error en upload-selfie: {str(e)}')
        return jsonify({
            'success': False,
            'error': f'Error al procesar la solicitud: {str(e)}'
        }), 500

@app.route('/delete-ine', methods=['POST'])
def delete_ine():
    filepath = os.path.join(UPLOAD_FOLDER, 'ine.jpg')
    if os.path.exists(filepath):
        os.remove(filepath)
        return jsonify({'message': 'Archivo eliminado correctamente'})
    return jsonify({'message': 'No se encontr√≥ el archivo para eliminar'})

@app.route('/start-facial-recognition', methods=['POST'])
def start_facial_recognition():
    try:
        # Obtener los datos de la solicitud
        data = request.get_json()
        if not data or 'foto' not in data:
            return jsonify({'success': False, 'error': 'No se proporcion√≥ la foto'}), 400
            
        cliente_id = data.get('clienteId', 'desconocido')
        
        # Ruta al archivo de INE subido
        ine_path = os.path.join(UPLOAD_FOLDER, 'ine.jpg')
        
        if not os.path.exists(ine_path):
            return jsonify({'success': False, 'error': 'No se encontr√≥ la imagen de INE'}), 400
        
        try:
            # Cargar la imagen de INE
            ine_image = cv2.imread(ine_path)
            if ine_image is None:
                raise ValueError('No se pudo cargar la imagen de INE')
            
            # Procesar la imagen de la c√°mara (en base64)
            header, encoded = data['foto'].split(',', 1)
            binary_data = base64.b64decode(encoded)
            nparr = np.frombuffer(binary_data, np.uint8)
            cam_image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            
            if cam_image is None:
                raise ValueError('No se pudo procesar la imagen de la c√°mara')
            
            # Convertir a escala de grises para detecci√≥n de rostros
            gray_ine = cv2.cvtColor(ine_image, cv2.COLOR_BGR2GRAY)
            gray_cam = cv2.cvtColor(cam_image, cv2.COLOR_BGR2GRAY)
            
            # Detectar rostros en ambas im√°genes
            faces_ine = FACE_CASCADE.detectMultiScale(gray_ine, 1.1, 4)
            faces_cam = FACE_CASCADE.detectMultiScale(gray_cam, 1.1, 4)
            
            if len(faces_ine) == 0:
                return jsonify({
                    'success': False,
                    'error': 'No se detect√≥ ning√∫n rostro en la imagen de INE. Por favor, suba una foto donde sea visible su rostro.'
                })
                
            if len(faces_cam) == 0:
                return jsonify({
                    'success': False,
                    'error': 'No se detect√≥ ning√∫n rostro en la imagen de la c√°mara. Aseg√∫rese de que su rostro sea claramente visible.'
                })
            
            # Tomar la primera cara detectada en cada imagen
            x_ine, y_ine, w_ine, h_ine = faces_ine[0]
            x_cam, y_cam, w_cam, h_cam = faces_cam[0]
            
            # Recortar las caras
            face_ine = ine_image[y_ine:y_ine+h_ine, x_ine:x_ine+w_ine]
            face_cam = cam_image[y_cam:y_cam+h_cam, x_cam:x_cam+w_cam]
            
            # Redimensionar las im√°genes al mismo tama√±o para comparaci√≥n
            face_ine = cv2.resize(face_ine, (200, 200))
            face_cam = cv2.resize(face_cam, (200, 200))
            
            # Convertir a escala de grises para el reconocimiento
            face_ine_gray = cv2.cvtColor(face_ine, cv2.COLOR_BGR2GRAY)
            face_cam_gray = cv2.cvtColor(face_cam, cv2.COLOR_BGR2GRAY)
            
            # Calcular el error cuadr√°tico medio (MSE) entre las im√°genes
            mse = np.mean((face_ine_gray - face_cam_gray) ** 2)
            
            # Convertir MSE a un porcentaje de similitud (menor MSE = m√°s similar)
            max_mse = 10000  # Valor m√°ximo esperado para MSE
            similitud = max(0, 100 - (mse / max_mse * 100))
            
            # Determinar si las caras coinciden basado en el umbral
            coincide = similitud >= (SIMILARITY_THRESHOLD * 100)
            
            # Registrar el resultado
            logger.info(f'Comparaci√≥n de rostros - Cliente: {cliente_id}, Similitud: {similitud:.2f}%, Coincide: {coincide}')
            
            return jsonify({
                'success': True,
                'coincide': coincide,
                'similitud': round(similitud, 2),
                'mensaje': 'Comparaci√≥n completada exitosamente',
                'puedeContinuar': coincide
            })
            
        except Exception as e:
            logger.error(f'Error al comparar rostros: {str(e)}')
            return jsonify({
                'success': False,
                'error': f'Error al comparar los rostros: {str(e)}',
                'puedeContinuar': False
            }), 500
            
    except Exception as e:
        logger.error(f'Error en el proceso de reconocimiento facial: {str(e)}')
        return jsonify({
            'success': False,
            'error': f'Error en el proceso de reconocimiento facial: {str(e)}',
            'puedeContinuar': False
        }), 500

# Ruta para servir archivos de plantillas
@app.route('/templates/<path:template_name>')
def serve_template(template_name):
    return render_template(template_name)

# Ruta para servir archivos CSS de m√≥dulos
@app.route('/static/css/<path:filename>')
def serve_module_css(filename):
    return send_from_directory('static/css', filename)

# Ruta para servir archivos JS de m√≥dulos
@app.route('/static/js/<path:filename>')
def serve_module_js(filename):
    return send_from_directory('static/js', filename)

# Ruta para comparar rostros
@app.route('/comparar_rostros', methods=['POST'])
def comparar_rostros():
    try:
        data = request.get_json()
        
        # Verificar que se hayan proporcionado ambas im√°genes
        if 'imagen1' not in data or 'imagen2' not in data:
            return jsonify({
                'error': 'Se requieren ambas im√°genes para la comparaci√≥n',
                'coinciden': False,
                'porcentaje': 0.0
            }), 400
        
        # Decodificar las im√°genes base64
        try:
            # Decodificar la primera imagen
            img1_data = base64.b64decode(data['imagen1'])
            nparr1 = np.frombuffer(img1_data, np.uint8)
            img1 = cv2.imdecode(nparr1, cv2.IMREAD_COLOR)
            
            # Decodificar la segunda imagen
            img2_data = base64.b64decode(data['imagen2'])
            nparr2 = np.frombuffer(img2_data, np.uint8)
            img2 = cv2.imdecode(nparr2, cv2.IMREAD_COLOR)
            
            # Verificar que las im√°genes se cargaron correctamente
            if img1 is None or img2 is None:
                raise ValueError("No se pudieron cargar una o ambas im√°genes")
                
        except Exception as e:
            logger.error(f"Error al decodificar las im√°genes: {str(e)}")
            return jsonify({
                'error': 'Error al procesar las im√°genes',
                'coinciden': False,
                'porcentaje': 0.0
            }), 400
        
        # Redimensionar im√°genes al mismo tama√±o
        img1 = cv2.resize(img1, (200, 200))
        img2 = cv2.resize(img2, (200, 200))
        
        # Convertir a escala de grises
        gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
        gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)
        
        # Calcular histogramas de color
        hist1 = cv2.calcHist([img1], [0, 1, 2], None, [8, 8, 8], [0, 256, 0, 256, 0, 256])
        hist2 = cv2.calcHist([img2], [0, 1, 2], None, [8, 8, 8], [0, 256, 0, 256, 0, 256])
        
        # Normalizar los histogramas
        hist1 = cv2.normalize(hist1, hist1).flatten()
        hist2 = cv2.normalize(hist2, hist2).flatten()
        
        # Calcular la correlaci√≥n entre los histogramas
        correlacion = cv2.compareHist(hist1, hist2, cv2.HISTCMP_CORREL)
        
        # Usar el clasificador LBPH para comparar rasgos faciales
        recognizer = cv2.face.LBPHFaceRecognizer_create()
        
        # Crear etiquetas para el entrenamiento
        labels = np.array([1, 2])
        
        try:
            # Entrenar con las dos im√°genes
            recognizer.train([gray1, gray2], labels)
            
            # Predecir la similitud
            label1, confidence1 = recognizer.predict(gray1)
            label2, confidence2 = recognizer.predict(gray2)
            
            # Calcular la confianza promedio (invertir porque menor es mejor en LBPH)
            conf_promedio = 100 - ((confidence1 + confidence2) / 2)
            
            # Combinar ambas m√©tricas (peso mayor al LBPH)
            similitud = (correlacion * 30 + conf_promedio * 70) / 100
            
            # Ajustar umbral de coincidencia (40% de similitud m√≠nima)
            coinciden = similitud > 40
            
            return jsonify({
                'coinciden': coinciden,
                'porcentaje': similitud,
                'mensaje': 'Comparaci√≥n completada correctamente'
            })
            
        except Exception as e:
            logger.error(f"Error en reconocimiento facial: {str(e)}")
            # Si falla el reconocimiento, usar solo la correlaci√≥n de histogramas
            return jsonify({
                'coinciden': correlacion > 0.4,
                'porcentaje': correlacion * 100,
                'mensaje': 'Comparaci√≥n b√°sica completada'
            })
        
    except Exception as e:
        logger.error(f"Error en el servidor: {str(e)}", exc_info=True)
        return jsonify({
            'error': 'Error interno del servidor al comparar rostros',
            'coinciden': False,
            'porcentaje': 0.0
        }), 500

# Ruta para servir archivos de datos
@app.route('/data/<path:filename>')
def serve_data(filename):
    return send_from_directory('data', filename)

# Ruta para servir el template de planes disponibles
@app.route('/planes-disponibles')
def planes_disponibles():
    try:
        logger.info("Sirviendo el template de Planes Disponibles")
        # Verificar si el archivo de plantilla existe
        template_path = os.path.join(app.template_folder, '2.PlanesDisponibles.html')
        logger.info(f"Buscando plantilla en: {template_path}")
        
        if not os.path.exists(template_path):
            logger.error(f"Archivo de plantilla no encontrado: {template_path}")
            return "Error: Archivo de plantilla no encontrado", 404
            
        # Leer el contenido del archivo directamente para verificar que sea accesible
        try:
            with open(template_path, 'r', encoding='utf-8') as f:
                content = f.read()
                logger.info(f"Plantilla le√≠da correctamente, tama√±o: {len(content)} bytes")
        except Exception as file_error:
            logger.error(f"Error al leer el archivo de plantilla: {str(file_error)}")
            return f"Error al leer el archivo de plantilla: {str(file_error)}", 500
            
        # Intentar renderizar la plantilla
        try:
            rendered = render_template('2.PlanesDisponibles.html')
            response = make_response(rendered)
            response.headers['Content-Type'] = 'text/html; charset=utf-8'
            return response
        except TemplateNotFound as tnf:
            logger.error(f"Plantilla no encontrada: {str(tnf)}")
            return f"Error: Plantilla no encontrada - {str(tnf)}", 404
        except TemplateError as te:
            logger.error(f"Error en la plantilla: {str(te)}")
            return f"Error en la plantilla: {str(te)}", 500
            
    except Exception as e:
        logger.error(f"Error inesperado al cargar el template de Planes Disponibles: {str(e)}", exc_info=True)
        return f"Error inesperado al cargar el template: {str(e)}", 500

# Ruta para la c√°mara de reconocimiento facial
@app.route('/camera')
def camera():
    """
    Ruta que muestra la interfaz de la c√°mara para reconocimiento facial
    """
    try:
        return render_template('camera.html')
    except TemplateNotFound:
        return "La funcionalidad de c√°mara no est√° disponible en este momento.", 404
    except Exception as e:
        app.logger.error(f"Error al cargar la c√°mara: {str(e)}")
        return "Ocurri√≥ un error al cargar la c√°mara. Por favor, intente m√°s tarde.", 500

# Ruta para el reporte de falla
@app.route('/reportar-falla')
def reportar_falla():
    """
    Ruta para mostrar el formulario de reporte de fallas.
    """
    try:
        # Registrar la solicitud
        logger.info("Sirviendo formulario de reporte de falla")
        
        # Renderizar la plantilla HTML del formulario de reporte de falla
        return render_template('3.ReportarFalla.html')
    except TemplateError as e:
        logger.error(f"Error al cargar la plantilla de reporte de falla: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Error al cargar el formulario de reporte de falla'
        }), 500

# Ruta para el cambio de contrase√±a WiFi
@app.route('/cambio-contrasena')
def cambio_contrasena():
    """
    Ruta para mostrar el formulario de cambio de contrase√±a WiFi.
    """
    logger.info("Acceso a la ruta /cambio_contrasena")
    try:
        # Verificar si el archivo de plantilla existe
        template_path = os.path.join(app.template_folder, '5.CambioContrasena.html')
        if not os.path.exists(template_path):
            return f"Error: No se encontr√≥ el archivo de plantilla en {template_path}", 404
            
        # Verificar si el archivo CSS existe
        css_path = os.path.join(app.static_folder, 'css', '5.CambioContrasena.css')
        if not os.path.exists(css_path):
            return f"Error: No se encontr√≥ el archivo CSS en {css_path}", 404
            
        logger.info(f"Archivos encontrados. Renderizando plantilla...")
        return render_template('5.CambioContrasena.html')
    except Exception as e:
        logger.error(f"Error al cargar el template de cambio de contrase√±a: {str(e)}")
        return f"Error al cargar el formulario: {str(e)}", 500

# Ruta de prueba para ver el contenido del CSS
@app.route('/test_css')
def test_css():
    try:
        css_path = os.path.join(app.static_folder, 'css', '5.CambioContrasena.css')
        with open(css_path, 'r', encoding='utf-8') as f:
            css_content = f.read()
        return f"<pre style='white-space: pre-wrap;'>{css_content}</pre>"
    except Exception as e:
        return f"Error al leer el archivo CSS: {str(e)}", 500

@app.route('/validar-ine', methods=['POST'])
def validar_ine():
    """
    Endpoint para validar un INE/IFE subido por el usuario
    """
    try:
        # Verificar que se haya enviado un archivo
        if 'ine' not in request.files:
            return jsonify({
                'exito': False,
                'mensaje': 'No se ha proporcionado ning√∫n archivo',
                'errores': ['No se proporcion√≥ ning√∫n archivo']
            }), 400
        
        file = request.files['ine']
        
        # Verificar que el archivo tenga un nombre
        if file.filename == '':
            return jsonify({
                'exito': False,
                'mensaje': 'No se ha seleccionado ning√∫n archivo',
                'errores': ['No se seleccion√≥ ning√∫n archivo']
            }), 400
        
        # Verificar la extensi√≥n del archivo
        if not (file.filename.lower().endswith(('.png', '.jpg', '.jpeg', '.pdf'))):
            return jsonify({
                'exito': False,
                'mensaje': 'Formato de archivo no soportado',
                'errores': ['El formato de archivo debe ser PNG, JPG o PDF']
            }), 400
        
        # Obtener el ID del cliente (obligatorio)
        cliente_id = request.form.get('cliente_id')
        if not cliente_id:
            return jsonify({
                'exito': False,
                'mensaje': 'Se requiere el ID del cliente',
                'errores': ['No se proporcion√≥ el ID del cliente']
            }), 400
        
        # Procesar el INE
        resultado = ine_processor.process_ine(file)
        
        # Si hubo un error en el procesamiento, devolverlo
        if not resultado.get('success', False):
            return jsonify({
                'exito': False,
                'mensaje': 'Error al procesar el documento',
                'errores': [resultado.get('error', 'Error desconocido al procesar el INE')]
            }), 400
        
        # Validar contra la base de datos (obligatorio)
        validacion = ine_processor.validate_against_database(
            resultado['data'], 
            cliente_id
        )
        
        if not validacion.get('valid', False):
            return jsonify({
                'exito': False,
                'mensaje': validacion.get('message', 'Error en la validaci√≥n del documento'),
                'errores': validacion.get('errores', ['No se pudo validar el documento']),
                'score': validacion.get('score', 0),
                'datos_extraidos': resultado['data']
            }), 400
        
        # Si todo sali√≥ bien, devolver los datos validados
        return jsonify({
            'exito': True,
            'mensaje': 'Documento validado correctamente',
            'score': validacion.get('score', 100),
            'datos': resultado['data']
        })
        
    except Exception as e:
        logger.error(f"Error en validar_ine: {str(e)}", exc_info=True)
        return jsonify({
            'exito': False,
            'mensaje': 'Error al procesar la solicitud',
            'errores': [f'Error interno: {str(e)}']
        }), 500

@app.route('/uploads/<filename>')
def uploaded_file(filename):
    """
    Sirve archivos subidos desde el directorio de uploads.
    """
    try:
        # Asegurarse de que el archivo existe
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        if not os.path.exists(filepath):
            return jsonify({'error': 'Archivo no encontrado'}), 404
            
        return send_from_directory(
            app.config['UPLOAD_FOLDER'], 
            filename, 
            as_attachment=False,
            mimetype='image/jpeg'  # Ajustar seg√∫n el tipo de archivo si es necesario
        )
    except Exception as e:
        logger.error(f'Error al servir el archivo {filename}: {str(e)}')
        return jsonify({'error': 'Error al procesar la solicitud'}), 500

@app.route('/comprobante')
def comprobante():
    """
    Ruta para mostrar el formulario de env√≠o de comprobante de pago.
    """
    try:
        logger.info('=== INICIO DE LA SOLICITUD /comprobante ===')
        logger.info(f'Directorio de trabajo: {os.getcwd()}')
        logger.info(f'Ruta de plantillas: {app.template_folder}')
        
        # Verificar si la plantilla existe
        template_path = os.path.join(app.template_folder, '4.Comprobante.html')
        logger.info(f'Buscando plantilla en: {template_path}')
        
        if not os.path.exists(template_path):
            error_msg = f'No se encontr√≥ la plantilla en: {template_path}'
            logger.error(error_msg)
            return jsonify({'error': error_msg}), 404
            
        logger.info('Plantilla encontrada, intentando renderizar...')
        
        # A√±adir par√°metro de versi√≥n para evitar cach√©
        response = make_response(render_template('4.Comprobante.html', version=datetime.now().timestamp()))
        
        # Configurar encabezados para permitir la carga en iframe
        response.headers['X-Frame-Options'] = 'SAMEORIGIN'
        response.headers['Content-Security-Policy'] = "frame-ancestors 'self'"
        
        logger.info('Plantilla renderizada con √©xito')
        return response
        
    except TemplateError as e:
        error_msg = f'Error en la plantilla: {str(e)}'
        logger.error(error_msg)
        logger.error(traceback.format_exc())
        return jsonify({'error': error_msg, 'type': 'template_error'}), 500
        
    except Exception as e:
        error_msg = f'Error al cargar el formulario de comprobante: {str(e)}'
        error_type = type(e).__name__
        logger.error(f'{error_msg} (Tipo: {error_type})')
        logger.error(traceback.format_exc())
        return jsonify({
            'error': 'No se pudo cargar el formulario de comprobante',
            'type': error_type,
            'details': str(e)
        }), 500

if __name__ == '__main__':
    # Configuraci√≥n del servidor
    host = '0.0.0.0'
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_DEBUG', 'True') == 'True'
    
    # Configuraci√≥n adicional para el servidor de desarrollo
    options = {
        'host': host,
        'port': port,
        'debug': debug,
        'use_reloader': True,
        'use_debugger': debug,
        'passthrough_errors': True
    }
    
    logger.info(f"Iniciando servidor en http://{host}:{port}")
    logger.info(f"Modo debug: {debug}")
    logger.info(f"Python version: {sys.version}")
    logger.info(f"Encoding - stdout: {sys.stdout.encoding}, stderr: {sys.stderr.encoding}, default: {sys.getdefaultencoding()}")
    
    # Iniciar el servidor
    app.run(**options)
